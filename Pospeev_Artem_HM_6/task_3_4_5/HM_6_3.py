# Есть два файла: в одном хранятся ФИО пользователей сайта, а в другом — данные об их хобби.
# Известно, что при хранении данных используется принцип: одна строка — один пользователь, разделитель между
# значениями — запятая. Написать код, загружающий данные из обоих файлов и формирующий из них словарь: ключи —
# ФИО, значения — данные о хобби. Сохранить словарь в файл. Проверить сохранённые данные. Если в файле,
# хранящем данные о хобби, меньше записей, чем в файле с ФИО, задаём в словаре значение None. Если наоборот — выходим
# из скрипта с кодом «1». При решении задачи считать, что объём данных в файлах во много раз меньше объема ОЗУ.
# Фрагмент файла с данными о пользователях (users.csv):
# Иванов,Иван,Иванович
# Петров,Петр,Петрович
# Фрагмент файла с данными о хобби (hobby.csv):
# скалолазание,охота
# горные лыжи
# 4. * (вместо 3) Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ (разумеется,
# не нужно реально создавать такие большие файлы, это просто задел на будущее проекта).
# Также реализовать парсинг данных из файлов — получить отдельно фамилию, имя и отчество для пользователей и
# название каждого хобби: преобразовать в какой-нибудь контейнерный тип (список, кортеж, множество, словарь).
# Обосновать выбор типа. Подумать, какие могут возникнуть проблемы при парсинге. В словаре должны храниться данные,
# полученные в результате парсинга.
# 5. ** (вместо 4) Решить задачу 4 и реализовать интерфейс командной строки, чтобы можно было задать путь к
# обоим исходным файлам и путь к выходному файлу со словарём. Проверить работу скрипта для случая, когда все
# файлы находятся в разных папках.


from itertools import zip_longest

CODING = 'utf-8'


def user_hobby(name_users_file, name_hobby_file):
    with open(name_users_file, 'r', encoding=CODING) as f_us:
        with open(name_hobby_file, 'r', encoding=CODING) as f_h:
            for line_us, line_hobby in zip_longest(f_us, f_h, fillvalue=None):
                if not line_us:   # проверяем на выход
                    exit('1')
                if line_hobby:  # избегаем None в строке
                    line_hobby = list(line_hobby.replace('\n', '').split(','))  # преобразовываем хобби в список
                rslt = (line_us.replace(',', ' ').replace('\n', ''), line_hobby)  # подготавливаем к выводу
                yield rslt


def write_users(argv):
    program, name_users_file, name_hobby_file, name_rslt_file = argv
    with open(name_rslt_file, 'w', encoding=CODING) as f_write:
        for tpl_for_wirte in (user_hobby(name_users_file, name_hobby_file)):  # перебираем входные файлы генератором
            f_write.write(f'{tpl_for_wirte[0]} : {tpl_for_wirte[1]}\n')  # форматируем для удобства


if __name__ == '__main__':
    import sys

    write_users(sys.argv)
